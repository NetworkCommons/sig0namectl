
<html>
	<head>
		<meta charset="utf-8"/>
		<script src="wasm_exec.js"></script>
		<script>
			// not the nices way to hook these up but it works.
			// might work for "document", too with some better trickery
			window.goFuncs = {};

			const go = new Go();
			WebAssembly.instantiateStreaming(fetch("demo.wasm"), go.importObject).then((result) => {
				go.run(result.instance);
			});

			function concatArrayBuffers(chunks/*: Uint8Array[]*/) {
					const result = new Uint8Array(chunks.reduce((a, c) => a + c.length, 0));
					let offset = 0;
					for (const chunk of chunks) {
							result.set(chunk, offset);
							offset += chunk.length;
					}
					return result;
			}

			function _base64ToArrayBuffer( buffer ) {
					var binary_string =  window.atob( buffer );
					var len = binary_string.length;
					var bytes = new Uint8Array( len );
					for (var i = 0; i < len; i++)        {
							bytes[i] = binary_string.charCodeAt(i);
					}
					return bytes;
			}

			function _arrayBufferToBase64( buffer ) {
					var binary = '';
					var bytes = new Uint8Array( buffer );
					var len = bytes.byteLength;
					for (var i = 0; i < len; i++) {
							binary += String.fromCharCode( bytes[ i ] );
					}
					return window.btoa( binary );
			}

			const input = Uint8Array.from("foo".split("").map(c => c.charCodeAt(0)));
			const converted = _arrayBufferToBase64(input);
			const andBack = _base64ToArrayBuffer(converted)

			// make sure input and andBack are the same
			if (input.length != andBack.length) {
				console.error("input and andBack are different lengths")
			}
			for (let i = 0; i < input.length; i++) {
				if (input[i] != andBack[i]) {
					console.error("input and andBack differ at index", i)
				}
			}

			async function queryViaFetch() {
				const qryData = document.getElementById("query-data").value
				if (qryData == "") {
					console.error("empty #query-data - prepare first")
					return
				}

				const qryUrl = new URL(`https://doh.zenr.io/dns-query?dns=${qryData}`)
				const resp = await fetch(qryUrl, {
					method: "get",
					headers: {
                        'Accept': 'application/dns-message',
						"Content-Type": "application/dns-message"
					}
				})

				const data = await resp.arrayBuffer()
				document.getElementById("dns-answer").value = _arrayBufferToBase64(data)
			}

			async function updateViaFetch() {
				const entryAddr = document.getElementById("entry-address").value
				if (entryAddr == "") {
					alert("empty #entry-address")
					return
				}

				const encodedUpdate = goFuncs["update"](entryAddr)
				const bodyBuf = _base64ToArrayBuffer(encodedUpdate)

				const qryUrl = new URL(`https://doh.zenr.io/dns-query`)
				const resp = await fetch(qryUrl, {
					method: "POST",
					headers: {
						"Content-Type": "application/dns-message"
					},
					body: bodyBuf
				})

				const data = await resp.arrayBuffer()
				document.getElementById("dns-answer").value = _arrayBufferToBase64(data)
			}

			async function requestKey() {
				const newName = document.getElementById("new-name").value
				if (newName == "") {
					alert("empty #new-name")
					return
				}

				const newKeyReq = goFuncs["newKeyRequest"]

				newKeyReq(newName, "doh.zenr.io").then(() => {
					console.log("key requested!")
				}).catch(err => alert(err.message))
           		}

			function listKeys() {
				const div = document.getElementById("existing-keys")
				if (div.children.length > 0) {
					div.removeChild(div.children[0])
				}

				const ul = document.createElement("ul")

				const list = window.goFuncs.listKeysAsJson
				for (const k of list()) {
					const li = document.createElement("li")
					li.innerHTML = JSON.stringify(k.Name).slice(1,-1)

					ul.appendChild(li)
				}
				div.appendChild(ul)

				return
			}

			// getKeysForDomain()
			//	list keys in the keystore 
			//	for which a given domain is a subdomain of the key's FQDN
			//
			function getKeysForDomain() {
				var searchDomain = document.getElementById("keys-for-domain").value
				if (! searchDomain.endsWith('.')) {
					searchDomain = searchDomain + '.'
				}

				const div = document.getElementById("domain-key")
				if (div.children.length > 0) {
					div.removeChild(div.children[0])
				}

				const ul = document.createElement("ul")

				const keyList = window.goFuncs.listKeysAsJson
				for (const k of keyList()) {
					if (searchDomain.endsWith(k.Key.split("\t")[0])) {
						const li = document.createElement("li")
						li.innerHTML = JSON.stringify(k.Name).slice(1,-1)
						ul.appendChild(li)
					}
				}
				div.appendChild(ul)

				return
			}


		</script>
	</head>
	<body>
		<h2>DNS Keys</h2>
      		<h3>List</h3>
     		<button onclick="listKeys()">Update</button>
		<div id="existing-keys"></div>


		<h3>Request</h3>
	  	<p>
			  <input type="text" id="new-name" placeholder="mythingymajig.zenr.io">
			  <button onclick="requestKey()">Request new Key</button>
		</p>	
		<h3>Search Keystore for Key to sign update for a given Subdomain</h3>
		<p>
			  <input type="text" id="keys-for-domain" placeholder="mythingymajig.zenr.io">
			  <button onclick="getKeysForDomain()">Find key in keystore</button>
			  <div id="domain-key"></div>
		</p>
		<h3>Import Key pair files from filesystem into Browser Keystore</h3>
		<p>
			<input type="file" id="input-key" accept=".key"/>
			<input type="file" id="input-private" accept=".private"/>
			<div id="imported-key"></div>
		</p>
		<script>
			/// Import Key from file pair
			///
			const streamToText = async (blob) => {
				const readableStream = await blob.getReader();
				const chunk = await readableStream.read();

				return new TextDecoder('utf-8').decode(chunk.value);
			};

			const bufferToText = (buffer) => {
				const bufferByteLength = buffer.byteLength;
				const bufferUint8Array = new Uint8Array(buffer, 0, bufferByteLength);

				return new TextDecoder().decode(bufferUint8Array);
			};

			document.getElementById('input-key').addEventListener('change', function(e) {
				let file = document.getElementById('input-key').files[0];

				(async () => {
					const fileContent = await file.text();

					console.log('.text()', fileContent);

					const fileContentStream = await file.stream();

					console.log('.stream()', await streamToText(fileContentStream));

					const buffer = await file.arrayBuffer();

					console.log('.buffer()', bufferToText(buffer));

					const fileSliceBlob = file.slice(0, file.length);
					const fileSliceBlobStream = await fileSliceBlob.stream();

					console.log('.slice() and .stream()', await streamToText(fileSliceBlobStream));
				})();
			});

			document.getElementById('input-private').addEventListener('change', function(e) {
				let file = document.getElementById('input-private').files[0];

				(async () => {
					const fileContent = await file.text();

					console.log('.text()', fileContent);

					const fileContentStream = await file.stream();

					console.log('.stream()', await streamToText(fileContentStream));

					const buffer = await file.arrayBuffer();

					console.log('.buffer()', bufferToText(buffer));

					const fileSliceBlob = file.slice(0, file.length);
					const fileSliceBlobStream = await fileSliceBlob.stream();

					console.log('.slice() and .stream()', await streamToText(fileSliceBlobStream));
				})();
			});
		</script>
	</body>
</html>
