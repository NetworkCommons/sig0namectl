#!/bin/bash
#
# process_key 
# 	Processes signal "requests" to _signal.<zone> ie CDS, CDNSKEY, and KEY records to zone master.
#------------------------------------------------------------------------------

# load helpful functions
for i in functions/*.sh
do
        . ${i}
        [[ -n ${DEBUG_SOURCED} ]] && echo "Sourced ${PWD}/functions/$i ..."
done

#------------------------------------------------------------------------------

set_vars

send_update() {
        # sends updates via nsupdate
        #
        # uses multiple environment variables
        # TODO this needs tidying & normalising for generic use
	# ZONE
	# NEW_SUBZONE
	# SOA_MASTER
	#
	[[ ! -n ${ZONE} ]] && echo "Error: ${FUNCNAME[0]}(): SUBZONE environment variable is undefined." && exit 1
	[[ ! -n ${NEW_SUBZONE} ]] && echo "Error: ${FUNCNAME[0]}(): NEW_SUBZONE environment variable is undefined." && exit 1
	[[ ! -n ${SOA_MASTER} ]] && echo "Error: ${FUNCNAME[0]}(): SOA_MASTER environment variable is undefined." && exit 1
	#
	#
	NSUPDATE_SET_SERVER="server ${SOA_MASTER}"

	# form SIG0 private auth key param
	if [[ -n ${NSUPDATE_AUTH_SIG0_KEYID} ]]; then
	        NSUPDATE_PARAM="-k ${NSUPDATE_SIG0_KEYPATH}/${NSUPDATE_AUTH_SIG0_KEYID}"
	else
	        NSUPDATE_PARAM=""
	fi


	if [[ -n ${DEBUG} ]]; then
		echo
		echo "${FUNCNAME[0]}(): ZONE              =	${ZONE}"
		echo "${FUNCNAME[0]}(): ZONE_SOA_MASTER   =	${ZONE_SOA_MASTER}"
		echo "${FUNCNAME[0]}(): NEW_SUBZONE   =	${NEW_SUBZONE}"

		echo
		echo "${FUNCNAME[0]}(): SUBZONE Requested =	${NEW_SUBZONE}"
		echo "${FUNCNAME[0]}():   DNS Update SIG0 Auth KEY pair =	${NSUPDATE_AUTH_SIG0_KEYID}"
		echo "${FUNCNAME[0]}():   NEW_SUBZONE_SIG0_KEY =	${NEW_SUBZONE_SIG0_KEY}"

		echo
		echo "${FUNCNAME[0]}():   NSUPDATE_SET_SERVER =	${NSUPDATE_SET_SERVER}"
		echo "${FUNCNAME[0]}():   NSUPDATE_PARAM = ${NSUPDATE_PARAM}"
		echo "${FUNCNAME[0]}():   NSUPDATE_ACTION = ${NSUPDATE_ACTION}"
		echo "${FUNCNAME[0]}():   NSUPDATE_PRECONDITION = ${NSUPDATE_PRECONDITION}"

		echo
		echo "${FUNCNAME[0]}(): nsupdate commands to send"
		echo
		echo "${FUNCNAME[0]}(): ${NSUPDATE_SET_SERVER}"
		echo "${FUNCNAME[0]}(): ${NSUPDATE_PRECONDITION}"
		echo "${FUNCNAME[0]}(): ${NSUPDATE_ITEM_SIG0_KEY}"
		echo "${FUNCNAME[0]}(): send"
		echo "${FUNCNAME[0]}(): quit"
	fi


	[[ -n ${DEBUG} ]] && echo && echo "Sending zone master (${ZONE_SOA_MASTER}) 'update ${NSUPDATE_ACTION}' resource record requests via nsupdate..."

cat <<EOF | nsupdate ${NSUPDATE_PARAM}
${NSUPDATE_SET_SERVER}
${NSUPDATE_PRECONDITION}
${NSUPDATE_ITEM_SIG0_KEY}
send
quit
EOF
}

# find existing SIG0 auth keypair for nsupdate parameter
[[ ! -n ${NSUPDATE_AUTH_SIG0_KEYID} ]] && get_sig0_keyid NSUPDATE_AUTH_SIG0_KEYID ${NSUPDATE_AUTH_SIG0_KEY_FQDN} ${NSUPDATE_SIG0_KEYPATH}

# find zone master for ${SIGNAL_SUBZONE}.${ZONE} which may be different from zone master of ${ZONE}
SIGNAL_SOA_MASTER=$( get_soa_master "${SIGNAL_SUBZONE}.${ZONE}" )
if [[ ! -n ${SIGNAL_SOA_MASTER} ]]; then
         echo "Warning: ZONE ${SIGNAL_SUBZONE}.${ZONE} SOA record does not resolve"
         exit 1
fi

UPDATE_TTL=${UPDATE_TTL:-"60"}

# set nsupdate pre-condition based on action 'add' or 'delete'
NSUPDATE_ACTION=${NSUPDATE_ACTION:-"add"}
if [ "${NSUPDATE_ACTION}" == "add" ]; then
        NSUPDATE_PRECONDITION_SET="nxdomain"
else
        NSUPDATE_PRECONDITION_SET="yxdomain"
fi


echo
echo "PENDING REQUESTS"
echo
dig @${ZONE_SOA_MASTER} +noall +answer +nottl +noclass PTR ${SIGNAL_SUBZONE}.${ZONE}
echo
echo "PENDING KEY INSERTION REQUESTS"
echo
REQUEST_QUEUE="`dig @${SIGNAL_SOA_MASTER} +short ${SIGNAL_SUBZONE}.${ZONE} PTR`"
[[ -n ${TEST_REQUEST} ]] && REQUEST_QUEUE="${REQUEST_QUEUE} zembla._signal.zenr.io testzone._signal.zenr.io dns-oarc._signal.zenr.io _signal._signal.zenr.io below.test._signal.zenr.io"

for request_ptr in ${REQUEST_QUEUE}; do
        # get requested KEY from SIGNAL_SOA_MASTER
	#request_key="`dig @${SIGNAL_SOA_MASTER} +noall +answer +multiline ${request_ptr} KEY`"
	request_key="`dig @${SIGNAL_SOA_MASTER} +noall +answer ${request_ptr} KEY`"
        # remove signal zone FQDN
	request_key="`echo ${request_key} | cut -f3- -d' '`"
        request_key_subzone="${request_ptr%%\.${SIGNAL_SUBZONE}*}"
        request_key_fqdn="${request_key_subzone}.${ZONE}"
        echo "-- REQUEST FQDN: ${request_ptr} is requesting key '${request_key_fqdn}' insertion into zone \"${ZONE}\":"
	request_key_fqdn_dig="`dig @${ZONE_SOA_MASTER} +noall +answer +nocrypto +dnssec ${request_key_fqdn} ANY``dig @${ZONE_SOA_MASTER} +noall +authority +nocrypto +nodnssec ${request_key_fqdn} NS | grep -v SOA`"
	if [[ ! -n ${request_key_fqdn_dig} || ${NSUPDATE_ACTION} == "delete" ]]; then
		request_key_fqdn_status="IS ${NSUPDATE_ACTION}-able"
        	echo "* ${request_ptr} ${request_key_fqdn_status}"
        	echo "${request_key_fqdn} ${request_key}"
		# set SOA_MASTER & NEW_SUBZONE for send_update()
		SOA_MASTER="${ZONE_SOA_MASTER}"
		NEW_SUBZONE="${request_key_subzone}"
		NEW_SUBZONE_SIG0_KEY=${request_key##*.}
		NSUPDATE_PRECONDITION="prereq ${NSUPDATE_PRECONDITION_SET} ${NEW_SUBZONE}.${ZONE}"
		NSUPDATE_ITEM_SIG0_KEY="update ${NSUPDATE_ACTION} ${NEW_SUBZONE}.${ZONE} ${UPDATE_TTL} ${NEW_SUBZONE_SIG0_KEY}"
		# add successful request
		send_update
		if [[ -n ${DEBUG} ]]; then
			echo "Validate current entries via 'dig @${ZONE_SOA_MASTER} +short ${NEW_SUBZONE}.${ZONE} KEY' ..."
			echo "KEY     `dig @${ZONE_SOA_MASTER} +short ${NEW_SUBZONE}.${ZONE} KEY`"
		fi
	else
		request_key_fqdn_status="IS NOT available, as  DNS resource records already exist for '${request_key_fqdn}'"
        	echo "* ${request_key_fqdn} ${request_key_fqdn_status}"
		# echo "${request_key_fqdn_dig}"
	fi
       	echo
done
 
exit 1

