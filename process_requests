#!/bin/bash
#
# process_key 
# 	Processes signal "requests" to _signal.<zone> ie CDS, CDNSKEY, and KEY records to zone master.
#------------------------------------------------------------------------------

# load helpful functions
for i in functions/*.sh
do
        . ${i}
        [[ -n ${DEBUG_SOURCED} ]] && echo "Sourced ${PWD}/functions/$i ..."
done

#------------------------------------------------------------------------------

set_vars

# send_update() {
#         # sends updates via nsupdate
#         #
#         # uses multiple environment variables
#         # TODO this needs tidying & normalising for generic use
# 	# ZONE
# 	# NEW_SUBZONE
# 	# SOA_MASTER
# 	#
# 	[[ ! -n ${ZONE} ]] && echo "Error: ${FUNCNAME[0]}(): SUBZONE environment variable is undefined." && exit 1
# 	[[ ! -n ${NEW_SUBZONE} ]] && echo "Error: ${FUNCNAME[0]}(): NEW_SUBZONE environment variable is undefined." && exit 1
# 	[[ ! -n ${SOA_MASTER} ]] && echo "Error: ${FUNCNAME[0]}(): SOA_MASTER environment variable is undefined." && exit 1
# 	#
# 	#
# 	NSUPDATE_SET_SERVER="server ${SOA_MASTER}"
# 
# 	# form SIG0 private auth key param
# 	if [[ -n ${NSUPDATE_AUTH_SIG0_KEYID} ]]; then
# 	        NSUPDATE_PARAM="-k ${NSUPDATE_SIG0_KEYPATH}/${NSUPDATE_AUTH_SIG0_KEYID}"
# 	else
# 	        NSUPDATE_PARAM=""
# 	fi
# 
# 	if [[ -n ${DEBUG} ]]; then
# 		echo
# 		echo "${FUNCNAME[0]}(): ZONE          =	${ZONE}"
# 		echo "${FUNCNAME[0]}(): SOA_MASTER    =	${ZONE_SOA_MASTER}"
# 		echo "${FUNCNAME[0]}(): NEW_SUBZONE   =	${NEW_SUBZONE}"
# 
# 		echo
# 		echo "${FUNCNAME[0]}(): SUBZONE Requested =	${NEW_SUBZONE}"
# 		echo "${FUNCNAME[0]}():   DNS Update SIG0 Auth KEY pair =	${NSUPDATE_AUTH_SIG0_KEYID}"
# 		echo "${FUNCNAME[0]}():   NEW_SUBZONE_SIG0_KEY =	${NEW_SUBZONE_SIG0_KEY}"
# 
# 		echo
# 		echo "${FUNCNAME[0]}():   NSUPDATE_SET_SERVER =	${NSUPDATE_SET_SERVER}"
# 		echo "${FUNCNAME[0]}():   NSUPDATE_PARAM = ${NSUPDATE_PARAM}"
# 		echo "${FUNCNAME[0]}():   NSUPDATE_ACTION = ${NSUPDATE_ACTION}"
# 		echo "${FUNCNAME[0]}():   NSUPDATE_PRECONDITION = ${NSUPDATE_PRECONDITION}"
# 
# 		echo
# 		echo "${FUNCNAME[0]}(): nsupdate commands to send"
# 		echo
# 		echo "${FUNCNAME[0]}(): ${NSUPDATE_SET_SERVER}"
# 		echo "${FUNCNAME[0]}(): ${NSUPDATE_PRECONDITION}"
# 		echo "${FUNCNAME[0]}(): ${NSUPDATE_ITEM_SIG0_KEY}"
# 		echo "${FUNCNAME[0]}(): send"
# 		echo "${FUNCNAME[0]}(): quit"
# 	fi
# 
# 
# 	[[ -n ${DEBUG} ]] && echo && echo "Sending zone master (${ZONE_SOA_MASTER}) 'update ${NSUPDATE_ACTION}' resource record requests via nsupdate..."
# 
# 	if [[ ! -n ${NSUPDATE_DISABLE} ]]; then
# cat <<EOF | nsupdate ${NSUPDATE_PARAM}
# ${NSUPDATE_SET_SERVER}
# ${NSUPDATE_PRECONDITION}
# ${NSUPDATE_ITEM_SIG0_KEY}
# send
# quit
# EOF
# 	else
# 		echo "${FUNCNAME[0]}(): updates disabled. NSUPDATE_DISABLE='${NSUPDATE_DISABLE}'"
# 	fi
# }

# find existing SIG0 auth keypair for nsupdate parameter
[[ ! -n ${NSUPDATE_AUTH_SIG0_KEYID} ]] && get_sig0_keyid NSUPDATE_AUTH_SIG0_KEYID ${NSUPDATE_AUTH_SIG0_KEY_FQDN} ${NSUPDATE_SIG0_KEYPATH}

# find zone master for ${SIGNAL_SUBZONE}.${ZONE} which may be different from zone master of ${ZONE}
SIGNAL_SOA_MASTER=$( get_soa_master "${SIGNAL_SUBZONE}.${ZONE}" )
if [[ ! -n ${SIGNAL_SOA_MASTER} ]]; then
         echo "Warning: ZONE ${SIGNAL_SUBZONE}.${ZONE} SOA record does not resolve"
         exit 1
fi

NSUPDATE_ACTION=${NSUPDATE_ACTION:-"add"} # ensures default action
UPDATE_TTL=${UPDATE_TTL:-"60"} # ensures default TTLs for RRs

echo
echo "LIST of  KEY REQUESTS"
echo
dig @${ZONE_SOA_MASTER} +noall +answer +nottl +noclass +noidnout PTR ${SIGNAL_SUBZONE}.${ZONE}
echo
echo "PROCESSING KEY REQUESTS"
echo
REQUEST_QUEUE="`dig @${SIGNAL_SOA_MASTER} +short ${SIGNAL_SUBZONE}.${ZONE} PTR`"
# [[ -n ${TEST_REQUEST} ]] && REQUEST_QUEUE="${REQUEST_QUEUE} testzone._signal.zenr.io _signal._signal.zenr.io below.test._signal.zenr.io"

for request_ptr in ${REQUEST_QUEUE}; do
        # get requested KEY from SIGNAL_SOA_MASTER
	request_key="`dig @${SIGNAL_SOA_MASTER} +noall +answer ${request_ptr} KEY`"
        # remove signal zone FQDN
	request_key="`echo ${request_key} | cut -f3- -d' '`"
        request_key_subzone="${request_ptr%%\.${SIGNAL_SUBZONE}*}"
        request_key_fqdn="${request_key_subzone}.${ZONE}"

	case ${NSUPDATE_ACTION} in
		add)
			# test for ANY usual DNS RR, as well as NS delegation RRs (which are not covered by ANY)
			request_key_fqdn_dig="`dig @${ZONE_SOA_MASTER} +noall +answer +nocrypto +dnssec ${request_key_fqdn} ANY``dig @${ZONE_SOA_MASTER} +noall +authority +nocrypto +nodnssec ${request_key_fqdn} NS | grep -v SOA`"
			# send add update iff no DNS RR or NS exists
			if [[ ! -n ${request_key_fqdn_dig} ]]; then
				# set SOA_MASTER & NEW_SUBZONE for send_update()
				# SOA_MASTER="${ZONE_SOA_MASTER}"
				NSUPDATE_PRECONDITION_SET="nxdomain"
				NEW_SUBZONE="${request_key_subzone}"
				NEW_SUBZONE_SIG0_KEY=${request_key##*.}
				NSUPDATE_PRECONDITION="prereq ${NSUPDATE_PRECONDITION_SET} ${NEW_SUBZONE}.${ZONE}"
				NSUPDATE_ITEM_SIG0_KEY="update ${NSUPDATE_ACTION} ${NEW_SUBZONE}.${ZONE} ${UPDATE_TTL} ${NEW_SUBZONE_SIG0_KEY}"
				# add successful request
				send_nsupdate "${ZONE}" "$(echo ${NSUPDATE_PRECONDITION};echo ${NSUPDATE_ITEM_SIG0_KEY})" "${NSUPDATE_AUTH_SIG0_KEY_FQDN}" 
				#send_update
				key_display="`dig @${ZONE_SOA_MASTER} +noall +answer +nottl +noclass +nocrypto +idnout ${request_key_fqdn} KEY`"
				request_key_fqdn_status="KEY '${request_key_fqdn}' submitted to ${NSUPDATE_ACTION} under zone '${ZONE}' with '[${key_display#*[}', IDN '${key_display%.*}'."
			else
				request_key_fqdn_status="KEY '${request_key_fqdn}' IS NOT submitted to ${NSUPDATE_ACTION} under zone '${ZONE}', as DNS resource records already exist."
			fi
			;;
		delete)
			# test for KEY DNS RR to delete (only deletes KEY & no other RR)
			request_key_fqdn_dig="`dig @${ZONE_SOA_MASTER} +noall +answer +nocrypto +dnssec ${request_key_fqdn} KEY`"
			# send delete update iff KEY FQDN exists in zone
			if [[ -n ${request_key_fqdn_dig} ]]; then
                                # SOA_MASTER="${ZONE_SOA_MASTER}"
				NSUPDATE_PRECONDITION_SET="yxdomain"
                                NEW_SUBZONE="${request_key_subzone}"
                                NEW_SUBZONE_SIG0_KEY=${request_key##*.}
                                NSUPDATE_PRECONDITION="prereq ${NSUPDATE_PRECONDITION_SET} ${NEW_SUBZONE}.${ZONE}"
                                NSUPDATE_ITEM_SIG0_KEY="update ${NSUPDATE_ACTION} ${NEW_SUBZONE}.${ZONE} ${UPDATE_TTL} ${NEW_SUBZONE_SIG0_KEY}"
                                # add successful request
                                key_display="`dig @${ZONE_SOA_MASTER} +noall +answer +nottl +noclass +nocrypto +idnout ${request_key_fqdn} KEY`"
				send_nsupdate "${ZONE}" "$(echo ${NSUPDATE_PRECONDITION};echo ${NSUPDATE_ITEM_SIG0_KEY})" "${NSUPDATE_AUTH_SIG0_KEY_FQDN}" 
				# send_update
                                request_key_fqdn_status="KEY '${request_key_fqdn}' submitted to ${NSUPDATE_ACTION} under zone '${ZONE}', with '[${key_display#*[}', IDN '${key_display%.*}'."
			else
				request_key_fqdn_status="KEY '${request_key_fqdn}' IS NOT submitted to ${NSUPDATE_ACTION} under zone '${ZONE}', as no DNS KEY resource record exists."
			fi
			;;
		*)
			# NSUPDATE_ACTION should default to "add" - should never get here
			echo "Error: NSUPDATE_ACTION is set to '${NSUPDATE_ACTION}', but must be set to 'add' or 'delete'."
			exit 1
			;;
	esac
	echo "${request_key_fqdn_status}"
done
