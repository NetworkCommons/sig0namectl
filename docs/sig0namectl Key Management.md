# sig0namectl 

## Keypair Generation

From man page of `dnssec-keygen`:

> When `dnssec-keygen` completes successfully, it prints a string of the form `Knnnn.+aaa+iiiii` to the standard output. This is an identification string for the key it has generated.
> * nnnn is the key name.
> * aaa is the numeric representation of the algorithm.
> * *iiiii is the key identifier (or footprint).
>
> `dnssec-keygen` creates two files, with names based on the printed string. `Knnnn.+aaa+iiiii.key` contains the public key, and `Knnnn.+aaa+iiiii.private` contains the private key.
>
> The `.key` file contains a DNS KEY record that can be inserted into a zone file (directly or with a $INCLUDE statement).
>
> The `.private` file contains algorithm-specific fields. For obvious security reasons, this file does not have general read permission.
>

## Key Identifier clarification

Key identifiers (key ids or footprints) for KEY & DNSKEY RR files referred to in the `dnssec-keygen` man page correspond to what is referred to as key 'tags' in DNSSEC terminology (RFC4034 see [3.3](https://www.rfc-editor.org/rfc/rfc4034#section-3.3)). For example, the filename id component of a zone's ZSK DNSKEY corresponds to the RRSIG key tag field in the zone it signs. So in theory, the C reference code example in [RFC4034 Appendix B](https://www.rfc-editor.org/rfc/rfc4034#appendix-B) should generate key identifiers.

Note that `dig` also calculates this ID from the KEY RR itself.

For example:
```
$ ls Kvortex* && dig +short +dnssec +rrcomments vortex.zenr.io KEY
Kvortex.zenr.io.+015+56161.key  Kvortex.zenr.io.+015+56161.private
512 3 15 2MK3KZkUgYQVumU9bhy1KzIZ2FhFQZ8yLP2nFMJRCEQ= ; alg = ED25519 ; key id = 56161
```


## sig0 Key Usage

### nsupdate
 From the man page of `nsupdate`:

`nsupdate` is used to submit Dynamic DNS Update requests, as defined in RFC 2136, to a name server. This allows resource records to be added or removed from a zone without manually editing the zone file. A single update request can contain requests to add or remove more than one resource record.

Zones that are under dynamic control via nsupdate or a DHCP server should not be edited by hand. Manual edits could conflict with dynamic updates and cause data to be lost.

The  resource  records  that  are  dynamically  added  or removed with nsupdate must be in the same zone. Requests are sent to the zone's primary server, which is identified by the MNAME field of the zone's SOA record.

Transaction signatures can be used to authenticate the Dynamic DNS updates. These use the TSIG resource record type described in  RFC  2845,  the SIG(0) record described in RFC 2535 and RFC 2931, or GSS-TSIG as described in RFC 3645.

...

SIG(0) uses public key cryptography. To use a SIG(0) key, the public key must be stored in a KEY record in a zone served by the name server.

...

**-k keyfile**

This option indicates the file containing the TSIG authentication key. Keyfiles may be in two formats:  
* a  single  file  containing  a named.conf-format  key  statement,  which may be generated automatically by ddns-confgen; or a pair of files whose names are of the format `K{name}.+157.+{random}.key` and `K{name}.+157.+{random}.private`, which can be generated by dnssec-keygen. The **-k** option can also be used to specify a SIG(0) key used to authenticate Dynamic DNS update requests. In this case, the key specified is not an HMAC-MD5 key.

## Local Keystore

sig0namectl uses the environment variable `NSUPDATE_SIG0_KEYPATH` to be the directory it uses to manage all keypairs generated. It can be set though the configuration files or overriden by command line library option **-k**.

Default value in **`env`** configuation file:

`NSUPDATE_SIG0_KEYPATH="${PWD}/keystore"`

Key generation through `request_key` writes newly generated key files in the directory path of `${NSUPDATE_SIG0_KEYPATH}`.

Workflow scripts use this environment variable to prepend a default path to keypairs to invoke `nsupdate` with a **-k ${NSUPDATE_SIG0_KEYPATH}/keyfile** argument.

## Key Management

sig0namectl uses the environment variable `SIGNAL_SUBZONE` to define the subzone where name requests are managed.

Default value in **`env`** configuation file:

`SIGNAL_SUBZONE="_signal"`
